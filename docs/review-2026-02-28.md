# CutRoom ‚Äî Comprehensive Code Review
**Date:** 2026-02-28  
**Reviewer:** AI Code Review Agent  
**Scope:** `server/`, `src/`, `tests/`, config files  
**Version examined:** current `main` branch HEAD

---

## Table of Contents
1. [Code Review](#1-code-review)
   - [Security Vulnerabilities](#11-security-vulnerabilities)
   - [Architecture & Anti-Patterns](#12-architecture--anti-patterns)
   - [Error Handling](#13-error-handling)
   - [Type Safety](#14-type-safety)
   - [Race Conditions & Concurrency](#15-race-conditions--concurrency)
   - [Dead Code & Code Smells](#16-dead-code--code-smells)
2. [Tech Debt Review](#2-tech-debt-review)
   - [Hardcoded Values](#21-hardcoded-values)
   - [DRY Violations](#22-dry-violations)
   - [Test Coverage Gaps](#23-test-coverage-gaps)
   - [Missing Error Boundaries](#24-missing-error-boundaries)
   - [Performance Bottlenecks](#25-performance-bottlenecks)
   - [Logging & Monitoring](#26-logging--monitoring)
   - [Documentation Gaps](#27-documentation-gaps)
3. [Project Health Review](#3-project-health-review)
4. [Summary](#4-summary)

---

# 1. CODE REVIEW

## 1.1 Security Vulnerabilities

### üî¥ CRITICAL ‚Äî Security: Encoding corruption renders user-facing toast strings unreadable

**File:** `src/stores/projectStore.ts:370-371`

**Issue:** Three Cyrillic strings in `describeAllAssets` are stored as CP1251/Latin-1 mojibake ‚Äî bytes that were re-interpreted during a file encoding accident. At runtime the toast popup displays garbage characters:

```ts
// Current (broken ‚Äî raw CP1251 bytes in a UTF-8 source file):
wasCancelled ? '–†—õ–†—ó–†—ë–°–É–†¬∞–†–Ö–†—ë–†¬µ –†—ï–°‚Äö–†—ò–†¬µ–†–Ö–†¬µ–†–Ö–†—ï' : '–†—õ–†—ó–†—ë–°–É–†¬∞–†–Ö–†—ë–†¬µ –†¬∑–†¬∞–†–Ü–†¬µ–°–Ç–°‚Ç¨–†¬µ–†–Ö–†—ï',
`–†—õ–†—ó–†—ë–°–É–†¬∞–†–Ö–†—ï ${done} –†—ë–†¬∑ ${toDescribe.length} –†¬∞–°–É–°–É–†¬µ–°‚Äö–†—ï–†–Ü`
```

**Suggestion:** Replace with correct UTF-8 literals (or unicode escapes, consistent with the rest of the file):

```ts
wasCancelled ? '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ' : '–û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ',
`–û–ø–∏—Å–∞–Ω–æ ${done} –∏–∑ ${toDescribe.length} –∞—Å—Å–µ—Ç–æ–≤`
```

Run `file -i src/stores/projectStore.ts` to confirm the file is saved as UTF-8, and enable an `.editorconfig` with `charset = utf-8`.

---

### üü† HIGH ‚Äî Security: No request body schema validation on any route

**File:** `server/routes/generate/image.ts`, `server/routes/shots.ts`, `server/routes/montage.ts` (all routes)

**Issue:** Every route handler reads `req.body.fieldName` directly with no schema validation library (no Zod, no Joi, no `express-validator`). Inputs are trusted to be of the expected type. For example:

```ts
// server/routes/shots.ts ~line 107
const { status } = req.body;
if (typeof status !== 'string') { ... }  // only the most basic check
```

Most routes only check that a single field exists or is a string. Deep nested objects, array entries, numeric ranges, and enum values for generation parameters are never validated. Malformed requests can cause unexpected behavior deeper in the pipeline (e.g., passing `duration: -9999` to Remotion or `gainDb: null` to ffmpeg).

**Suggestion:** Add a thin validation layer. Zod is already the ecosystem norm and works well with Express 5:

```ts
import { z } from 'zod'
const generateImageSchema = z.object({ /* ... */ })
const body = generateImageSchema.safeParse(req.body)
if (!body.success) return sendApiError(res, 400, body.error.message)
```

---

### üü† HIGH ‚Äî Security: Settings file write is non-atomic (data loss on crash)

**File:** `server/routes/settings.ts:40-43`

**Issue:** `writeSettings` calls `fs.writeFile` directly without the atomic temp-file rename pattern used for `project.json`. If the server crashes mid-write, `data/settings.json` is truncated and all API keys are lost:

```ts
async function writeSettings(settings: Settings): Promise<void> {
  await fs.mkdir(path.dirname(SETTINGS_PATH), { recursive: true });
  await fs.writeFile(SETTINGS_PATH, JSON.stringify(settings, null, 2), 'utf-8'); // ‚Üê NOT atomic
}
```

The project layer already has `writeFileAtomic()` (write to `.tmp` ‚Üí `rename`). Settings should use the same pattern.

**Suggestion:** Extract `writeFileAtomic` to a shared utility in `server/lib/file-utils.ts` and call it from both `storage.ts` and `settings.ts`.

---

### üü† HIGH ‚Äî Security: Arbitrary URL fetching (SSRF) in external image cache and media download

**File:** `server/lib/media-utils.ts:49`, `server/lib/external-image-cache.ts:~70`

**Issue:** User-supplied URLs from `shot.generatedImages[]` and `shot.videoFile` are fetched server-side without an allowlist check. An attacker who can write a project (e.g., via a compromised UI session) could insert `http://169.254.169.254/latest/meta-data/` or an internal service URL, causing the server to make requests on their behalf:

```ts
// media-utils.ts
const response = await fetch(url, { signal: AbortSignal.timeout(30_000) });
```

**Suggestion:** Validate the URL hostname against an allowlist of known AI provider domains before fetching:

```ts
const ALLOWED_HOSTS = /\.(fal\.run|fal\.media|replicate\.delivery|elevenlabs\.io)$/i
function assertExternalUrlSafe(url: string) {
  const { hostname } = new URL(url)
  if (!ALLOWED_HOSTS.test(hostname)) throw new Error(`Blocked SSRF to: ${hostname}`)
}
```

---

### üü† HIGH ‚Äî Security: Settings endpoint accepts and stores arbitrary JSON keys

**File:** `server/routes/settings.ts:86,118-121`

**Issue:** The PUT handler spreads the entire request body onto the settings object without whitelist filtering:

```ts
const updates = req.body as Partial<Settings>;
// ... no allowlist check ...
const merged: Settings = { ...existingClean, ...updates };
await writeSettings(merged);
```

An attacker could inject extra keys like `__proto__`, `constructor`, or inject unexpected runtime configuration. While prototype pollution risk is low with JSON.parse (creates clean objects), it is a pattern that should be tightened.

**Suggestion:** Define an explicit list of allowed settings keys and strip anything else before merging.

---

### üü° MEDIUM ‚Äî Security: Upload MIME type validated by extension only, not by file content

**File:** `server/routes/assets.ts` (multer config), `server/routes/montage.ts` (music upload)

**Issue:** File uploads check `req.file.mimetype` (provided by the HTTP client) or file extension, not the actual file magic bytes. A client can upload a malicious file with `Content-Type: image/jpeg` while its actual content is a shell script.

**Suggestion:** Use `sharp` (already a dependency) or `file-type` to detect MIME from the first bytes:

```ts
import { fileTypeFromBuffer } from 'file-type'
const type = await fileTypeFromBuffer(req.file.buffer.slice(0, 4100))
if (!type || !ALLOWED_TYPES.includes(type.mime)) { /* reject */ }
```

---

### üü° MEDIUM ‚Äî Security: Unconstrained `videoFile` path passed to `resolveProjectPath` in normalize

**File:** `server/lib/normalize.ts:149`

**Issue:** `normalizeClips` assumes `shot.videoFile` is a local relative path and passes it directly to `resolveProjectPath`:

```ts
const inputPath = resolveProjectPath(projectId, shot.videoFile);
```

If `shot.videoFile` is an external URL (which happens when caching fails on video generation via Replicate/fal), `resolveProjectPath` calls `path.resolve(baseDir, 'https://...')` which would produce an absolute path that fails `resolvePathWithin`'s escape check, resulting in an unhandled error thrown mid-render.

**Suggestion:** Guard with an explicit check:

```ts
if (shot.videoFile.startsWith('http://') || shot.videoFile.startsWith('https://')) {
  console.warn(`[normalize] Shot ${shot.id} has uncached external videoFile; skipping`);
  continue;
}
```

---

## 1.2 Architecture & Anti-Patterns

### üü† HIGH ‚Äî Architecture: Type definitions duplicated between server and client

**File:** `server/lib/storage.ts:8-160` vs `src/types/index.ts`

**Issue:** Core domain types (`Project`, `Shot`, `Brief`, `MontagePlan`, `RenderJob`, `DirectorReview`, etc.) are defined separately and independently in both the server layer and the frontend type layer. They are maintained in parallel but diverge silently:

- `server/lib/storage.ts` has `ShotMeta` with `selectedImage: string | null`; `src/types/index.ts` has `Shot` without `selectedImage`
- `src/types/index.ts` has `briefType: BriefType` on `Project`; the server never sets or reads this field
- `src/types/index.ts` has `ProjectSettings` with different fields than `server/lib/storage.ts:ProjectSettings`

**Suggestion:** Create a shared `shared/types.ts` package (or a `types/` directory at project root) consumed by both `server/` and `src/`. This is the standard Turborepo / monorepo approach; alternatively with simple file aliasing in `tsconfig.json`. At minimum, use a single source of truth and generate the other side.

---

### üü† HIGH ‚Äî Architecture: God components (800‚Äì1100 lines)

**Files:**
- `server/routes/generate/director.ts` ‚Äî **1122 lines**
- `server/routes/generate/image.ts` ‚Äî **754 lines**
- `src/components/SettingsView.tsx` ‚Äî **866 lines**
- `src/components/MontageView.tsx` ‚Äî **737 lines**
- `src/components/DirectorView.tsx` ‚Äî **618 lines**

**Issue:** These files violate single-responsibility principle. `director.ts` contains route handlers, LLM prompt building, feedback application logic, image re-generation orchestration, note resolution logic, and batch processing ‚Äî all in one file. `SettingsView.tsx` contains two quality normalization functions, a nav component, a section component, and the main 700-line form component.

**Suggestion:**
- Split `director.ts` into: `routes/generate/director/route.ts`, `routes/generate/director/review.ts`, `routes/generate/director/apply-feedback.ts`
- Extract `MontageView`'s steps into separate components: `VoiceoverStep.tsx`, `MusicStep.tsx`, `PlanStep.tsx`, `RenderStep.tsx`
- Extract `SettingsView`'s normalization logic into `lib/settings-normalization.ts`

---

### üü† HIGH ‚Äî Architecture: Two independent settings readers in server

**File:** `server/lib/config.ts` vs `server/routes/settings.ts:24-38`

**Issue:** Both `server/lib/config.ts` and `server/routes/settings.ts` independently define `readSettings()` functions that read the same `data/settings.json` file. They have slightly different interfaces (`GlobalSettings` vs `Settings`) and slightly different default handling. This creates a subtle dual-source-of-truth problem where settings changes only observed by one reader.

**Suggestion:** Remove the duplicated reader from `config.ts` and have it call the one canonical reader from `settings.ts`. Or better, create `server/lib/settings-store.ts` as the single I/O layer.

---

### üü° MEDIUM ‚Äî Architecture: Optimistic UI updates without rollback on API failure

**File:** `src/stores/projectStore.ts` (many actions)

**Issue:** Actions like `updateShot`, `updateShotStatus`, `updateBriefText`, `removeBriefAsset`, `batchUpdateShotStatus`, `deleteShotImage`, `deleteShotVideo` make an optimistic local state update, then fire a background API call. On failure, they only `console.error` ‚Äî the UI state is never reverted to the server truth:

```ts
updateShot: (projectId, shotId, updates) => {
  set(/* optimistic update */);
  api.shots.update(projectId, shotId, updates).catch((e) => {
    console.error('Failed to save shot:', e);  // UI is now stale! No rollback.
  });
},
```

**Suggestion:** Either (a) reload the project on failure: `.catch(() => get().loadProject(projectId))`, or (b) show a toast error and revert the previous value by storing it before the optimistic update.

---

### üü° MEDIUM ‚Äî Architecture: `describeAllAssets` runs sequentially, ignores concurrency pool

**File:** `src/stores/projectStore.ts:321-375`

**Issue:** Asset description loops sequentially with `for...of`, one API call at a time, despite the project having `src/lib/async-pool.ts` with `mapWithConcurrency`:

```ts
for (const asset of toDescribe) {
  if (!get().describeProgress.active) break;
  await api.assets.describe(projectId, asset.id);  // blocks next until done
}
```

A project with 30 assets takes 30√ó the latency of a single describe call.

**Suggestion:** Use `mapWithConcurrency(toDescribe, 3, async (asset) => { ... })` with a concurrency of 3‚Äì5, keeping cancellation by checking a shared flag.

---

### üü° MEDIUM ‚Äî Architecture: Unicode escapes for Cyrillic strings create unmaintainable source

**File:** `src/components/DirectorView.tsx` (throughout), `src/components/SettingsView.tsx:570-590`

**Issue:** Hundreds of Cyrillic strings are stored as `\u0420\u0435\u0432\u044c\u044e` escape sequences instead of readable UTF-8. This makes the code unreadable and very hard to maintain or translate:

```tsx
// DirectorView.tsx line ~28
{ id: 'script', label: '\u0420\u0435\u0432\u044c\u044e \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u044f', ... }
// Renders as: "–†–µ–≤—å—é —Å—Ü–µ–Ω–∞—Ä–∏—è"
```

This happened because the file was presumably opened in an editor that re-encoded the source. The `.editorconfig` approach above would prevent recurrence.

**Suggestion:** Run a one-time decode pass:
```bash
node -e "const f=require('fs');let s=f.readFileSync('src/components/DirectorView.tsx','utf8');s=s.replace(/\\\\u([0-9a-fA-F]{4})/g,(_,c)=>String.fromCharCode(parseInt(c,16)));f.writeFileSync('src/components/DirectorView.tsx',s,'utf8')"
```
Add `.editorconfig` with `charset = utf-8` and `end_of_line = lf` to prevent recurrence.

---

## 1.3 Error Handling

### üü° MEDIUM ‚Äî Error Handling: Background API errors in store are silently swallowed

**File:** `src/stores/projectStore.ts` ‚Äî all `updateXxx` methods

**Issue:** As noted above, background API failures produce only a console error. Users have no indication that their changes weren't saved. If the browser tab is refreshed after a failed background save, all changes are lost.

**Suggestion:** Add a "dirty" indicator to the store and display a persistent warning banner when background saves fail. At minimum, show an error toast:

```ts
api.shots.update(...).catch((e) => {
  useToastStore.getState().addToast('error', '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —à–æ—Ç', getActionErrorMessage(e))
  // optionally rollback
})
```

---

### üü° MEDIUM ‚Äî Error Handling: `generateScript` and `splitShots` don't clear stale error on retry

**File:** `src/stores/projectStore.ts:155-184`

**Issue:** `set({ error: null })` is correctly set at the start of these actions, but the `error` field lives on the global store and can be overwritten by concurrent actions (e.g., a failing image generation). This means displaying a single error string is not granular enough for the pipeline's concurrent nature.

**Suggestion:** Move error state to be per-operation or use the toast system exclusively. The global `error` string on the store is a pattern that doesn't scale.

---

### üîµ LOW ‚Äî Error Handling: `normalizeProject` silently repairs corrupt data without logging

**File:** `server/lib/storage.ts:336-419`

**Issue:** `normalizeProject` silently patches any missing or wrong field (e.g., assigns a new UUID if `id` is missing). This hides data corruption issues. In production, a project where id was reset to a new UUID would become orphaned.

**Suggestion:** Log a warning when critical fields need repair:

```ts
if (!project.id || typeof project.id !== 'string') {
  console.warn('[storage] normalizeProject: project missing id, generating new one');
  project.id = uuidv4();
}
```

---

## 1.4 Type Safety

### üü° MEDIUM ‚Äî Type Safety: `normalizeProject` uses `any` pervasively (‚â•30 casts)

**File:** `server/lib/storage.ts:336-419`

**Issue:** The normalization function casts to `any` throughout to perform field migrations:

```ts
const s = shot as any;
if (s.prompt && !s.imagePrompt) { ... }
(asset as any).id = uuidv4();
(project as any).directorState = { ... };
```

This bypasses all type checking during the most critical data-integrity code path.

**Suggestion:** Define a `LegacyProject` / `RawProject` input type with all the historic fields as optional, and write a typed migration function. Alternatively, at minimum, introduce a `MigratableShot` type for the migration block.

---

### üü° MEDIUM ‚Äî Type Safety: `ProjectSettings` interface mismatch between server and client

**File:** `server/lib/storage.ts:8-13` vs `src/types/index.ts:48-54`

**Issue:** The server's `ProjectSettings` has `{ scriptwriterPrompt, shotSplitterPrompt, model, temperature }` while the client's `ProjectSettings` has `{ textModel, imageModel, enhanceModel, masterPromptScriptwriter, ... }`. These are completely different shapes ‚Äî neither is a subset of the other. The server writes the server shape; the client reads the server shape as if it's the client shape, silently treating all fields as `undefined`.

**Suggestion:** Reconcile these two interfaces. The server shape appears to be the stored format; the client shape is what the UI expects. Either unify them or add a server-side DTO layer that maps one to the other.

---

### üü° MEDIUM ‚Äî Type Safety: `server/tsconfig.json` missing strictness flags

**File:** `server/tsconfig.json`

**Issue:** The server's `tsconfig.json` has `"strict": true` but is missing `"noUnusedLocals"`, `"noUnusedParameters"`, `"noFallthroughCasesInSwitch"` flags that are set on the frontend tsconfig. Dead variables and parameters in server code won't be caught at compile time.

**Suggestion:**

```json
{
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

---

### üîµ LOW ‚Äî Type Safety: `api.director.applyFeedback` returns `any`

**File:** `src/lib/api.ts:~255`

**Issue:**

```ts
applyFeedback: (...) => request<any>(`/projects/${projectId}/director/apply-feedback`, ...)
```

The return type is `any`, losing all type safety for callers.

**Suggestion:** Define a discriminated union type for the possible apply-feedback responses, or at minimum use `unknown` and add a type guard.

---

### üîµ LOW ‚Äî Type Safety: `briefType` field on frontend `Project` never set by server

**File:** `src/types/index.ts:65`

**Issue:** `Project.briefType: BriefType` exists in the client type but the server `Project` interface in `storage.ts` has no such field and never sets it. The field will always be `undefined` at runtime, silently making all `briefType`-dependent code dead.

**Suggestion:** Either remove the field from the client type, or add it to the server `Project` interface and persist it.

---

## 1.5 Race Conditions & Concurrency

### üü° MEDIUM ‚Äî Concurrency: Concurrent `generateImage` calls for the same shot are not deduplicated

**File:** `src/stores/projectStore.ts:196-234`

**Issue:** `generateImage` adds the shotId to `generatingShotIds` but doesn't block a second concurrent call for the same shot. If a user double-clicks "Generate", two simultaneous generation requests are made. The last one to complete wins and both files are saved, but the status management becomes inconsistent.

**Suggestion:** Add a guard at the start:

```ts
if (get().generatingShotIds.has(shotId)) return;
```

---

### üü° MEDIUM ‚Äî Concurrency: `describeAllAssets` cancellation has TOCTOU race

**File:** `src/stores/projectStore.ts:332-342`

**Issue:** The cancellation check `if (!get().describeProgress.active) break` is done between `await` calls, but `cancelDescribe()` sets `{ active: false }` and immediately resets the entire progress struct. If `cancelDescribe` is called after the last `await` but before the final `set(...)`, the `done` counter is read after it was already reset to 0:

```ts
const wasCancelled = !get().describeProgress.active;  // ‚Üê reads from already-reset state
set({ describeProgress: { active: false, ... } });
if (done > 0) { toast(...) }
```

**Suggestion:** Capture the cancellation state using a local variable set before the `for` loop's first check, not after.

---

### üü° MEDIUM ‚Äî Concurrency: `serializeProjectWrite` queue can grow unboundedly

**File:** `server/lib/storage.ts:271-285`

**Issue:** `serializeProjectWrite` chains promises correctly, but if a long-running job fails and keeps rethrowing, the `.catch(() => undefined)` on the previous promise silently swallows the error and lets the next write proceed on potentially corrupt state.

**Suggestion:** Log the caught error at the queue boundary so failures don't vanish silently:

```ts
const next = previous
  .catch((e) => console.error(`[storage] Queued write failed for ${id}:`, e))
  .then(task);
```

---

## 1.6 Dead Code & Code Smells

### üü° MEDIUM ‚Äî Dead Code: `sunoApiKey` field exists but has no Suno API integration

**File:** `server/routes/settings.ts:74,106-107,131`, `server/lib/config.ts:45`

**Issue:** `sunoApiKey` is masked, stored, and exposed through the settings API, and `AppSettings` in `src/types/index.ts` declares it. However there is no Suno API client or integration anywhere in the server. The music step only generates a text prompt for users to copy into the Suno web UI manually. The field misleads users into thinking API-driven music generation is supported.

**Suggestion:** Either remove `sunoApiKey` from settings (and add a comment explaining the manual workflow), or add a `TODO(suno-api): integrate when Suno releases stable API` marker.

---

### üîµ LOW ‚Äî Dead Code: `ProjectSettings` server-side model stored per-project is unused

**File:** `server/lib/storage.ts:168-243`, `server/lib/storage.ts:353-356`

**Issue:** `DEFAULT_SETTINGS` contains a large hardcoded `scriptwriterPrompt` and `shotSplitterPrompt` (Cyrillic, 2000+ chars) stored in every project's `settings` object. But all generation routes read the global `AppSettings.masterPromptScriptwriter` (from `getGlobalSettings()`), not the per-project settings. The per-project `settings` object is written on create and migrated but never read by any route handler.

**Suggestion:** Remove the per-project `settings` object (or deprecate it) and rely only on global settings. This simplifies data model and removes the massive per-project JSON bloat.

---

### üîµ LOW ‚Äî Code Smell: `selectedImage` stored in server `ShotMeta` but not exposed to client

**File:** `server/lib/storage.ts:64`

**Issue:** `ShotMeta.selectedImage: string | null` exists on the server model but `Shot` in `src/types/index.ts` has no `selectedImage` field. The field is never set by any route (it's normalized to `null`). It appears to be vestigial from an old UI feature.

**Suggestion:** Remove `selectedImage` from `ShotMeta` or implement it on the client.

---

### üîµ LOW ‚Äî Code Smell: `toastStore` uses module-level mutable state that doesn't reset between tests

**File:** `src/stores/toastStore.ts:16-17`

**Issue:**

```ts
let nextId = 0
const recentToastExpiry = new Map<string, number>()
```

Module-level mutable state persists across `vitest` test runs (since modules are cached). A toast deduplication in test A can unexpectedly suppress toasts in test B if run in the same worker.

**Suggestion:** Expose a `reset()` function and call it in `beforeEach`:

```ts
export function _resetToastStore() {
  nextId = 0
  recentToastExpiry.clear()
  useToastStore.setState({ toasts: [] })
}
```

---

# 2. TECH DEBT REVIEW

## 2.1 Hardcoded Values

### üü° MEDIUM ‚Äî Tech Debt: Critical constants hardcoded in source rather than configurable

| Value | File | Line | Should be |
|---|---|---|---|
| `'data/projects'` data directory | `server/lib/storage.ts:164` | 164 | `DATA_DIR` env var |
| `'data/settings.json'` | `server/routes/settings.ts:10` | 10 | `SETTINGS_PATH` env var |
| `50mb` JSON body limit | `server/app.ts:101` | 101 | `BODY_LIMIT_MB` env var |
| `1920` max upload dimension | `src/lib/imageUtils.ts:1` | 1 | configurable |
| `0.85` JPEG quality | `src/lib/imageUtils.ts:2` | 2 | configurable |
| `3840√ó2160` / `30fps` / `'h264'` render target | `server/lib/normalize.ts:25-28` | 25-28 | Plan fields |
| `'http://localhost:5173'` CORS allowlist | `server/app.ts:57-58` | 57 | Already env-configurable (`CORS_ORIGINS`) ‚úì |
| Rate limit defaults `120 req/60s` | `server/app.ts:73` | 73 | Already env-configurable ‚úì |

**Suggestion:** Move `DATA_DIR` and `SETTINGS_PATH` to `server/lib/config.ts` with environment variable overrides. The render format constants should come from the `MontagePlan.format` field (they partly do), but the fallback defaults should be documented.

---

### üîµ LOW ‚Äî Tech Debt: Default model IDs hardcoded in generation-models registry

**File:** `server/lib/generation-models.ts`

**Issue:** Specific model IDs like `'fal-ai/flux-kontext-max'`, `'fal-ai/kling-video/v2.1/pro/image-to-video'`, `'replicate:fofr/pulid-base'` are hardcoded in the static registry. When providers release new model versions, the registry must be updated manually.

**Suggestion:** This is partially addressed by the dynamic fal model discovery ‚Äî extend the dynamic path for video models too.

---

## 2.2 DRY Violations

### üü° MEDIUM ‚Äî Tech Debt: Error-handling boilerplate repeated in ~15 store actions

**File:** `src/stores/projectStore.ts`

**Issue:** Every async store action follows the same pattern:

```ts
actionName: async () => {
  const projectId = get().activeProjectId
  if (!projectId) return
  set({ loading: true, error: null })
  try {
    await api.something(projectId)
    const project = await api.projects.get(projectId)
    set((state) => ({ projects: state.projects.map(p => p.id === projectId ? project : p), loading: false }))
    toast('success', '...')
  } catch (e: any) {
    set({ error: getActionErrorMessage(e), loading: false })
    toast('error', '...', getActionErrorMessage(e))
  }
},
```

This pattern is copy-pasted ~15 times with minor variation.

**Suggestion:** Create a `withProjectAction` higher-order helper:

```ts
function withProjectAction(
  get: GetState, set: SetState,
  fn: (projectId: string) => Promise<void>,
  messages: { success: string, error: string }
) { /* ... */ }
```

---

### üü° MEDIUM ‚Äî Tech Debt: Loading/saving state pattern duplicated in every component

**File:** `src/components/MontageView.tsx`, `src/components/DirectorView.tsx`, `src/components/BriefEditor.tsx`, etc.

**Issue:** Each component independently manages `const [loading, setLoading] = useState(false)` with a `try { setLoading(true); await api...; } finally { setLoading(false) }` block. This is repeated ~40 times across the codebase.

**Suggestion:** Extract a `useAsyncAction` hook:

```ts
function useAsyncAction<T>(fn: () => Promise<T>) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const run = async () => {
    setLoading(true); setError(null)
    try { return await fn() }
    catch (e) { setError(getErrorMessage(e)); throw e }
    finally { setLoading(false) }
  }
  return { run, loading, error }
}
```

---

### üîµ LOW ‚Äî Tech Debt: Duplicate `resolveProjectPath` / path helpers across route files

**File:** Multiple route files import individually from `storage.js` and recompute project paths

**Issue:** Several route files build paths like `resolveProjectPath(id, 'shots', shotId, 'generated')` inline rather than having named path helpers. This creates subtle inconsistencies (e.g., one route uses `'brief/images'` while another builds the same path differently).

**Suggestion:** Add named path accessors to `storage.ts`:

```ts
export const projectPaths = {
  shotsDir: (projectId: string) => resolveProjectPath(projectId, 'shots'),
  shotGeneratedDir: (projectId: string, shotId: string) =>
    resolveProjectPath(projectId, 'shots', shotId, 'generated'),
  // ...
}
```

---

## 2.3 Test Coverage Gaps

### üü† HIGH ‚Äî Tech Debt: No CI workflow runs tests, lint, or build

**File:** `.github/workflows/` (only `codeql.yml` exists)

**Issue:** There is no GitHub Actions workflow that runs `npm test`, `npm run lint`, or `npm run build`. The CodeQL workflow only does static SAST scanning. A PR that breaks all unit tests or breaks TypeScript compilation would merge undetected.

**Suggestion:** Add `.github/workflows/ci.yml`:

```yaml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '22', cache: 'npm' }
      - run: npm ci
      - run: npm run lint
      - run: npm run build
      - run: npm test
```

---

### üü° MEDIUM ‚Äî Tech Debt: No tests for ffmpeg integration (`normalize.ts`)

**File:** `server/lib/normalize.ts` ‚Äî **0 tests**

**Issue:** `normalizeClips`, `probeFile`, `probeDuration`, `imageToVideo` are completely untested. These are the most critical functions in the render pipeline ‚Äî a bug here produces broken videos. The unit test for montage-plan mocks ffprobe but doesn't test the actual normalization logic.

**Suggestion:** Add `tests/unit/normalize.test.ts` with mocked `childProcess.execFile` (pattern already used in `montage-plan.test.ts`).

---

### üü° MEDIUM ‚Äî Tech Debt: No tests for render-worker lifecycle

**File:** `server/lib/render-worker.ts` ‚Äî untested beyond plan-reader subset

**Issue:** `RenderWorker.start()`, the job queue, progress reporting, error handling, and `delete` endpoint are not tested. The montage-render unit tests mock the worker at the route level.

**Suggestion:** Test `render-worker.ts` in isolation with a mocked Remotion renderer.

---

### üü° MEDIUM ‚Äî Tech Debt: No component tests for key UI flows

The following components have **zero tests**:

| Component | Risk |
|---|---|
| `BriefEditor.tsx` | File upload, brief text save |
| `ShotDetail.tsx` | Complex UI with 10+ actions |
| `ExportView.tsx` | ZIP download trigger |
| `ScriptView.tsx` | Script editing |
| `MontageView.tsx` | Full 6-step pipeline UI |
| `Lightbox.tsx` | Keyboard navigation |
| `Sidebar.tsx` | Project switching |

**Suggestion:** At minimum add smoke tests (`renders without crashing`) for each; add interaction tests for `ShotDetail` (generate/cancel/approve flow).

---

### üü° MEDIUM ‚Äî Tech Debt: `voiceover.ts` route file has no integration test

**File:** `server/routes/voiceover.ts` ‚Äî **0 direct integration tests**

**Issue:** There is no `tests/integration/voiceover.test.ts`. The voiceover endpoints in `montage.ts` are tested via `montage.test.ts`, but the separate `voiceover.ts` router (if it exists and has distinct endpoints) is untested.

**Suggestion:** Verify whether `voiceover.ts` is an active route file or dead code; if active, add tests.

---

### üîµ LOW ‚Äî Tech Debt: Security test suite has only 3 tests

**File:** `tests/integration/security.test.ts` ‚Äî **3 tests total**

**Issue:** Only API key middleware is tested. Missing:
- Rate limiting behavior (429 on overflow, reset after window)
- CORS rejection of non-allowlisted origins
- Path traversal attempts on shot/asset endpoints beyond the one `assets.test.ts` case
- Large body rejection

---

## 2.4 Missing Error Boundaries

### üü° MEDIUM ‚Äî Tech Debt: Only one root-level ErrorBoundary; no per-view boundaries

**File:** `src/main.tsx` (or `src/App.tsx`)

**Issue:** A single `<ErrorBoundary>` at the root means any unhandled render error in any child component crashes the entire app to the fallback UI. If the `DirectorView` throws during a malformed review response, the user loses access to the whole pipeline, including their project list.

**Suggestion:** Wrap each major view with its own `<ErrorBoundary fallback={<ViewError />}`:

```tsx
<ErrorBoundary key={activeView} fallback={<ViewErrorFallback view={activeView} />}>
  {activeView === 'director' && <DirectorView />}
</ErrorBoundary>
```

Use `key={activeView}` to reset the boundary when the user navigates away.

---

### üîµ LOW ‚Äî Tech Debt: No error boundary around `Lightbox` component

**File:** `src/components/Lightbox.tsx`

**Issue:** If a rendered image URL is malformed and triggers an `img` load error that propagates as an exception, the lightbox would crash the entire app. Image `onerror` is not handled.

**Suggestion:** Add `onError` handler to the `<img>` element to replace broken images with a placeholder.

---

## 2.5 Performance Bottlenecks

### üü° MEDIUM ‚Äî Tech Debt: `listProjects` makes N sequential synchronous disk reads

**File:** `server/lib/storage.ts:423-443`

**Issue:** `listProjects` reads every `project.json` one by one in a `for...of` loop:

```ts
for (const entry of entries) {
  const raw = await fs.readFile(filePath, 'utf-8');  // sequential
  projects.push(normalizeProject(JSON.parse(raw)));
}
```

With 50+ projects this adds noticeable latency on project list load. The full project data is loaded even though the sidebar only needs `id`, `name`, `created`, `stage`.

**Suggestion:** Parallelize the reads with `Promise.all`, and add a `listProjectsSummary()` function that reads only a project header (or maintains a lightweight index file):

```ts
const projects = await Promise.all(
  entries.filter(e => e.isDirectory()).map(async (entry) => {
    try {
      return normalizeProject(JSON.parse(await fs.readFile(..., 'utf-8')))
    } catch { return null }
  })
)
```

---

### üü° MEDIUM ‚Äî Tech Debt: Large Zustand store triggers broad re-renders

**File:** `src/stores/projectStore.ts`

**Issue:** The store holds the entire `projects` array. Any update to any project (even background status updates from `generatingShotIds`) triggers re-renders in all components subscribed to `projects`. The `ShotBoard` re-renders on every shot status change even if that shot isn't visible.

**Suggestion:** Use Zustand's selector granularity ‚Äî components should select only the specific slice they need:

```ts
// Instead of:
const { projects } = useProjectStore()  // triggers on ANY projects change

// Use:
const activeProject = useProjectStore(s => s.activeProject())
const shot = useProjectStore(s => s.projects.find(p => p.id === projectId)
  ?.shots.find(s => s.id === shotId))
```

Most components already do this correctly, but some still select broader slices.

---

### üîµ LOW ‚Äî Tech Debt: Brief text save fires immediately on every keystroke

**File:** `src/components/BriefEditor.tsx`

**Issue:** The comment says "debounced by the caller" but the `updateBriefText` store action fires the API call synchronously without any built-in debounce. If `BriefEditor` itself doesn't debounce (check required), every keystroke fires a PUT `/api/projects/:id` request.

**Suggestion:** Verify `BriefEditor` uses `useCallback` + a debounce (e.g., `useDeferredValue` or `lodash.debounce` with 500ms). Add debounce at the store level as a safety net.

---

## 2.6 Logging & Monitoring

### üü° MEDIUM ‚Äî Tech Debt: No structured logging; no request logging middleware

**File:** `server/app.ts`, `server/index.ts`

**Issue:** All logging uses raw `console.log` / `console.error`. There is no request logging middleware (morgan, pino-http), so there's no way to correlate a failed API call with server logs without adding debugging code. In production, you have no visibility into response times, error rates, or which endpoints are slow.

**Suggestion:**
1. Add `morgan` or `pino-http` to the Express app for request logging
2. Replace ad-hoc `console.error` calls with a structured logger (pino):

```ts
import pino from 'pino'
const logger = pino({ level: process.env.LOG_LEVEL || 'info' })
```

---

### üîµ LOW ‚Äî Tech Debt: AI generation failures have no telemetry or retry counting

**File:** `server/lib/fal-client.ts`, `server/lib/replicate-client.ts`, `server/lib/openrouter.ts`

**Issue:** Generation failures are logged to console but there's no tracking of: which model failed, at what rate, how many retries were consumed. This makes it impossible to detect when a provider is degraded.

**Suggestion:** Add a minimal structured log entry on each generation failure:

```ts
logger.warn({ model, provider: 'fal', attempt, error: e.message }, 'generation failed')
```

---

## 2.7 Documentation Gaps

### üü° MEDIUM ‚Äî Tech Debt: No `.env.example` file

**File:** Project root ‚Äî missing `.env.example`

**Issue:** New developers have no way to know which environment variables to configure. The README mentions `npm run dev:all` but doesn't list required environment variables. Variables like `API_ACCESS_KEY`, `REQUIRE_API_ACCESS_KEY`, `CORS_ORIGINS`, `FFMPEG_PATH`, `FFPROBE_PATH`, `NODE_ENV`, `PORT`, `RATE_LIMIT_MAX`, `RATE_LIMIT_WINDOW_MS` are only discoverable by reading source code.

**Suggestion:** Create `.env.example`:

```bash
# Server
PORT=3001
NODE_ENV=development

# Optional: Protect the API with a bearer key
# API_ACCESS_KEY=your-secret-key
# REQUIRE_API_ACCESS_KEY=false

# CORS (comma-separated)
CORS_ORIGINS=http://localhost:5173

# Rate limiting
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX=120

# ffmpeg paths (default: use system PATH)
# FFMPEG_PATH=/usr/local/bin/ffmpeg
# FFPROBE_PATH=/usr/local/bin/ffprobe
```

---

### üü° MEDIUM ‚Äî Tech Debt: No Docker or deployment documentation

**File:** README.md, project root

**Issue:** CutRoom depends on `ffmpeg`, `ffprobe`, Node.js 22+, and specific AI provider API keys. There is no `Dockerfile`, `docker-compose.yml`, or deployment guide. Self-hosting requires figuring out all dependencies manually.

**Suggestion:** Add a minimal `Dockerfile`:

```dockerfile
FROM node:22-alpine
RUN apk add --no-cache ffmpeg
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
EXPOSE 3001
CMD ["node", "--experimental-vm-modules", "server/index.js"]
```

---

### üîµ LOW ‚Äî Tech Debt: README architecture section incomplete

**File:** `README.md`

**Issue:** The architecture section only lists `server/routes/montage.ts` and a few lib files but omits the entire `server/routes/generate/` subtree (image, video, director, script), `server/routes/assets.ts`, `server/routes/shots.ts`, and `server/routes/export.ts` ‚Äî which are arguably the most important routes.

**Suggestion:** Update the architecture diagram to reflect the full route tree, or link to an auto-generated API reference.

---

# 3. PROJECT HEALTH REVIEW

## README Accuracy

**Score: 7/10**

The README is accurate for the quick start flow (`npm install && npm run dev:all`). The pipeline diagram and feature list are correct and up-to-date. The tech stack table is accurate.

**Missing:**
- Environment variable documentation ‚Üí no `.env.example`
- `ffmpeg` / `ffprobe` as required system dependencies (not mentioned in prerequisites)
- Docker/deployment section
- Contributing guide
- Known limitations (e.g., Suno integration is manual copy-paste, not API)
- API documentation link

---

## Package.json Scripts

### üü° MEDIUM ‚Äî Health: `test:e2e` requires a running server but fails silently in CI

**File:** `playwright.config.ts`, `package.json`

**Issue:** The `test:e2e` script launches `npm run server` and `npm run dev` as web servers, but these will fail if port 3001 or 5173 is already in use. In a CI environment without proper port management this causes Playwright tests to silently pass (the `reuseExistingServer: true` hides the issue if an old server is still running from a previous step).

**Suggestion:** Set `reuseExistingServer: !process.env.CI` in `playwright.config.ts` ‚Äî in CI always start fresh.

---

### ‚ö™ INFO ‚Äî Health: All scripts verified functional

| Script | Status | Notes |
|---|---|---|
| `dev` | ‚úÖ | Vite dev server |
| `build` | ‚úÖ | tsc + vite build |
| `lint` | ‚úÖ | ESLint with TS plugin |
| `server` | ‚úÖ | tsx watch |
| `dev:all` | ‚úÖ | concurrently |
| `test` | ‚úÖ | vitest run |
| `test:watch` | ‚úÖ | vitest watch |
| `test:unit` | ‚úÖ | 263/264 passing |
| `test:integration` | ‚úÖ | passing |
| `test:components` | ‚úÖ | passing |
| `test:e2e` | ‚ö†Ô∏è | requires running server |
| `test:all` | ‚ö†Ô∏è | vitest + playwright, CI concerns |

---

## CI/CD Status

### üü† HIGH ‚Äî Health: No CI pipeline runs tests or checks code quality

**Files:** `.github/workflows/`

**Issue:** Only `codeql.yml` exists. There is no workflow that:
- Runs `npm test` on PRs
- Runs `npm run lint`
- Runs `npm run build` to verify TypeScript compiles
- Runs E2E tests

CodeQL runs weekly and on push/PR but only performs SAST ‚Äî it does not catch test regressions or TypeScript errors.

**Suggestion:** Add a `ci.yml` workflow as described in ¬ß2.3.

---

## License Compliance

### ‚úÖ AGPL-3.0 Compliant

- `LICENSE` file is present (34,523 bytes ‚Äî full AGPL-3.0 text)
- `package.json` does not specify `"license"` field (minor)
- All dependencies are permissively licensed (MIT, Apache-2.0, BSD); none have AGPL/GPL-only licenses that would create copyleft conflicts
- AGPL-3.0 badge in README is accurate

**Suggestion:** Add `"license": "AGPL-3.0-only"` to `package.json` for tooling/SBOM compatibility.

---

## .gitignore Completeness

### üîµ LOW ‚Äî Health: `.gitignore` missing common entries

**File:** `.gitignore`

Current contents:
```
node_modules/
dist/
data/        ‚Üê good, keeps API keys out of git
*.log
.env
test-results/
playwright-report/
.worktrees/
```

**Missing entries:**

```
# IDE
.vscode/
.idea/
*.suo
*.ntvs*

# OS
.DS_Store
Thumbs.db

# TypeScript build cache
*.tsbuildinfo

# Test coverage
coverage/

# Vite cache
.vite/
```

---

## Environment Variable Documentation

### üü° MEDIUM ‚Äî Health: Environment variables undocumented

**All configurable env vars (none documented in README):**

| Variable | Default | Description |
|---|---|---|
| `PORT` | `3001` | HTTP server port |
| `NODE_ENV` | `development` | Controls error detail exposure in API responses |
| `API_ACCESS_KEY` | `''` | Optional bearer token to protect API |
| `REQUIRE_API_ACCESS_KEY` | `false` | If `true`, reject requests without `API_ACCESS_KEY` |
| `CORS_ORIGINS` | `''` | Comma-separated extra CORS origins |
| `RATE_LIMIT_WINDOW_MS` | `60000` | Rate limit window |
| `RATE_LIMIT_MAX` | `120` | Max requests per window per IP |
| `FFMPEG_PATH` | `ffmpeg` | Path to ffmpeg binary |
| `FFPROBE_PATH` | `ffprobe` | Path to ffprobe binary |

---

## Docker/Deployment Readiness

### üü† HIGH ‚Äî Health: No Docker or deployment artifacts

**Issue:** No `Dockerfile`, `docker-compose.yml`, or deployment guide. Production deployment requires:
1. Node.js 22+
2. ffmpeg + ffprobe system packages
3. Persistent volume for `data/` directory
4. Reverse proxy for the frontend build

**Suggestion:** See Dockerfile suggestion in ¬ß2.7.

---

## ESLint Coverage

### üîµ LOW ‚Äî Health: ESLint config doesn't cover `server/` files

**File:** `eslint.config.js`

**Issue:**

```js
{
  files: ['**/*.{ts,tsx}'],
  languageOptions: { globals: globals.browser },  // browser globals only!
}
```

Server files match `**/*.{ts,tsx}` but get browser globals (not Node.js globals). This can suppress legitimate lint errors in server code. Additionally, `tseslint.configs.recommended` without `type-checked` rules means type-aware lint rules (like `@typescript-eslint/no-floating-promises`) are disabled.

**Suggestion:**

```js
export default defineConfig([
  globalIgnores(['dist']),
  { files: ['src/**/*.{ts,tsx}'], languageOptions: { globals: globals.browser }, /* ... */ },
  { files: ['server/**/*.ts'],    languageOptions: { globals: globals.node    }, /* ... */ },
])
```

---

# 4. SUMMARY

## Findings by Severity

| Severity | Count |
|---|---|
| üî¥ CRITICAL | 1 |
| üü† HIGH | 9 |
| üü° MEDIUM | 22 |
| üîµ LOW | 12 |
| ‚ö™ INFO | 1 |
| **Total** | **45** |

---

## Top 5 Priorities

### P1 üî¥ Fix mojibake in `projectStore.ts:370-371`
Users see garbled text in the "Describe assets" toast. One-line fix, high visible impact.

### P2 üü† Add CI workflow for tests + lint + build
The most fundamental CI safety net is missing. Any broken PR could silently merge. 30-minute effort.

### P3 üü† Add input schema validation (Zod) to all routes
The entire backend accepts arbitrary unvalidated JSON. This is a security and reliability hazard. Add Zod as a dependency and validate at each route entry point.

### P4 üü† Unify type definitions between server and client
`server/lib/storage.ts` and `src/types/index.ts` are diverging copies. `briefType`, `selectedImage`, `ProjectSettings` shape mismatches will cause silent runtime bugs. Create a shared types package.

### P5 üü† Make settings file write atomic
`writeSettings` can produce a truncated `data/settings.json` on crash, wiping all API keys. Extract and reuse the existing `writeFileAtomic` helper.

---

## Overall Project Health Score

**7.0 / 10**

**Positives:**
- Excellent test infrastructure: 263/264 passing across unit, integration, and component tests. Coverage includes tricky scenarios (retry logic, fallback models, external image caching, mojibake detection in reviews).
- Strong security foundations: `resolvePathWithin` path traversal protection, optional API key auth, IP-based rate limiting, proper CORS allowlisting, `X-Content-Type-Options` headers.
- Thoughtful concurrency: `serializeProjectWrite` prevents project.json corruption under concurrent writes; `writeFileAtomic` prevents file truncation.
- Clean API client (`src/lib/api.ts`) with structured error handling.
- Good `mapWithConcurrency` utility exists and is well-tested.
- Active dependabot + CodeQL security scanning.

**Areas bringing score down:**
- No CI test/build workflow (biggest gap for a project of this complexity)
- Type duplication between server and client ‚Äî a ticking time bomb
- God files (director.ts at 1122 lines, SettingsView at 866 lines) make the codebase hard to navigate
- Source encoding corruption (mojibake) in active user-facing code
- Deployment story is absent (no Dockerfile, no .env.example)
- Background API failures in the Zustand store are silently dropped with no user feedback or rollback

With the top 5 priorities addressed, this project would be an 8.5/10 ‚Äî the architecture is fundamentally sound and the business logic is well-designed.
